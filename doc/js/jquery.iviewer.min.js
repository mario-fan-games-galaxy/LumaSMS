/*
 * iviewer Widget for jQuery UI
 * https://github.com/can3p/iviewer
 *
 * Copyright (c) 2009 - 2012 Dmitry Petrov
 * Dual licensed under the MIT and GPL licenses.
 *  - http://www.opensource.org/licenses/mit-license.php
 *  - http://www.gnu.org/copyleft/gpl.html
 *
 * Author: Dmitry Petrov
 * Version: 0.7.7
 */
(function ($, undefined) {
  const mouseEvents = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
  };


  const gesturesSupport = 'ongesturestart' in document.createElement('div');
  function makeMouseEvent(event) {
    const touch = event.originalEvent.changedTouches[0];
    return $.extend(event, {
      type: mouseEvents[event.type],
      which: 1,
      pageX: touch.pageX,
      pageY: touch.pageY,
      screenX: touch.screenX,
      screenY: touch.screenY,
      clientX: touch.clientX,
      clientY: touch.clientY,
      isTouchEvent: true,
    });
  }
  const mouseProto = $.ui.mouse.prototype;


  const _mouseInit = $.ui.mouse.prototype._mouseInit;
  mouseProto._mouseInit = function () {
    var self = this;
    self._touchActive = false;
    this.element.bind(`touchstart.${this.widgetName}`, (event) => {
      if (gesturesSupport && event.originalEvent.touches.length > 1) return;
      self._touchActive = true;
      return self._mouseDown(makeMouseEvent(event));
    });
    var self = this;
    this._mouseMoveDelegate = function (event) {
      if (
        gesturesSupport
        && event.originalEvent.touches
        && event.originalEvent.touches.length > 1
      ) return;
      if (self._touchActive) return self._mouseMove(makeMouseEvent(event));
    };
    this._mouseUpDelegate = function (event) {
      if (self._touchActive) {
        self._touchActive = false;
        return self._mouseUp(makeMouseEvent(event));
      }
    };
    $(document)
      .bind(`touchmove.${this.widgetName}`, this._mouseMoveDelegate)
      .bind(`touchend.${this.widgetName}`, this._mouseUpDelegate);
    _mouseInit.apply(this);
  };
  const setter = function (setter, getter) {
    return function (val) {
      if (arguments.length === 0) return getter.apply(this);
      setter.apply(this, arguments);
    };
  };
  const ieTransforms = {
    0: {
      marginLeft: 0,
      marginTop: 0,
      filter:
          'progid:DXImageTransform.Microsoft.Matrix(M11=1, M12=0, M21=0, M22=1, SizingMethod="auto expand")',
    },
    90: {
      marginLeft: -1,
      marginTop: 1,
      filter:
          'progid:DXImageTransform.Microsoft.Matrix(M11=0, M12=-1, M21=1, M22=0, SizingMethod="auto expand")',
    },
    180: {
      marginLeft: 0,
      marginTop: 0,
      filter:
          'progid:DXImageTransform.Microsoft.Matrix(M11=-1, M12=0, M21=0, M22=-1, SizingMethod="auto expand")',
    },
    270: {
      marginLeft: -1,
      marginTop: 1,
      filter:
          'progid:DXImageTransform.Microsoft.Matrix(M11=0, M12=1, M21=-1, M22=0, SizingMethod="auto expand")',
    },
  };


  const useIeTransforms = (function () {
    const el = document.createElement('div');
    el.style.cssText = ['-ms-', '', ''].join('filter:blur(2px); ');
    return !!el.style.cssText && document.documentMode < 9;
  }());
  $.widget('ui.iviewer', $.ui.mouse, {
    widgetEventPrefix: 'iviewer',
    options: {
      zoom: 'fit',
      zoom_base: 100,
      zoom_max: 800,
      zoom_min: 25,
      zoom_delta: 1.4,
      zoom_animation: true,
      ui_disabled: false,
      mousewheel: true,
      update_on_resize: true,
      onZoom: jQuery.noop,
      onAfterZoom: jQuery.noop,
      onStartDrag: jQuery.noop,
      onDrag: jQuery.noop,
      onStopDrag: jQuery.noop,
      onMouseMove: jQuery.noop,
      onClick: jQuery.noop,
      onStartLoad: null,
      onFinishLoad: null,
      onErrorLoad: null,
    },
    _create() {
      const me = this;
      this.dx = 0;
      this.dy = 0;
      this.img_object = {};
      this.zoom_object = {};
      this._angle = 0;
      this.current_zoom = this.options.zoom;
      if (this.options.src === null) return;
      this.container = this.element;
      this._updateContainerInfo();
      this.container.css('overflow', 'hidden');
      if (this.options.update_on_resize == true) {
        $(window).resize(() => {
          me.update();
        });
      }
      this.img_object = new $.ui.iviewer.ImageObject(
        this.options.zoom_animation,
      );
      if (this.options.mousewheel) {
        this.container.bind('mousewheel.iviewer', (ev, delta) => {
          const zoom = delta > 0 ? 1 : -1;


          const container_offset = me.container.offset();


          const mouse_pos = {
            x: ev.pageX - container_offset.left,
            y: ev.pageY - container_offset.top,
          };
          me.zoom_by(zoom, mouse_pos);
          return false;
        });
        if (gesturesSupport) {
          let gestureThrottle = +new Date();
          let originalScale; let
            originalCenter;
          this.img_object
            .object()
            .bind('touchstart', (ev) => {
              originalScale = me.current_zoom;
              const touches = ev.originalEvent.touches;


              let container_offset;
              if (touches.length == 2) {
                container_offset = me.container.offset();
                originalCenter = {
                  x:
                    (touches[0].pageX + touches[1].pageX) / 2
                    - container_offset.left,
                  y:
                    (touches[0].pageY + touches[1].pageY) / 2
                    - container_offset.top,
                };
              } else originalCenter = null;
            })
            .bind('gesturechange', (ev) => {
              const d = +new Date();
              if (d - gestureThrottle < 50) return;
              gestureThrottle = d;
              const zoom = originalScale * ev.originalEvent.scale;
              me.set_zoom(zoom, originalCenter);
              ev.preventDefault();
            })
            .bind('gestureend', (ev) => {
              originalCenter = null;
            });
        }
      }
      this.img_object
        .object()
        .click(e => me._click(e))
        .prependTo(this.container);
      this.container.bind('mousemove', (ev) => {
        me._handleMouseMove(ev);
      });
      this.loadImage(this.options.src);
      if (!this.options.ui_disabled) this.createui();
      this._mouseInit();
    },
    destroy() {
      $.Widget.prototype.destroy.call(this);
      this._mouseDestroy();
      this.img_object.object().remove();
      this.container.off('.iviewer');
      this.container.css('overflow', '');
    },
    _updateContainerInfo() {
      this.options.height = this.container.height();
      this.options.width = this.container.width();
    },
    update() {
      this._updateContainerInfo();
      this.setCoords(this.img_object.x(), this.img_object.y());
    },
    loadImage(src) {
      this.current_zoom = this.options.zoom;
      const me = this;
      this._trigger('onStartLoad', 0, src);
      this.container.addClass('iviewer_loading');
      this.img_object.load(
        src,
        () => {
          me._imageLoaded(src);
        },
        () => {
          me._trigger('onErrorLoad', 0, src);
        },
      );
    },
    _imageLoaded(src) {
      this.container.removeClass('iviewer_loading');
      this.container.addClass('iviewer_cursor');
      if (this.options.zoom == 'fit') this.fit(true);
      else this.set_zoom(this.options.zoom, true);
      this._trigger('onFinishLoad', 0, src);
    },
    fit(skip_animation) {
      const aspect_ratio = this.img_object.orig_width() / this.img_object.orig_height();
      const window_ratio = this.options.width / this.options.height;
      const choose_left = aspect_ratio > window_ratio;
      let new_zoom = 0;
      if (choose_left) new_zoom = (this.options.width / this.img_object.orig_width()) * 100;
      else new_zoom = (this.options.height / this.img_object.orig_height()) * 100;
      this.set_zoom(new_zoom, skip_animation);
    },
    center() {
      this.setCoords(
        -Math.round((this.img_object.display_width() - this.options.width) / 2),
        -Math.round(
          (this.img_object.display_height() - this.options.height) / 2,
        ),
      );
    },
    moveTo(x, y) {
      const dx = x - Math.round(this.options.width / 2);
      const dy = y - Math.round(this.options.height / 2);
      const new_x = this.img_object.x() - dx;
      const new_y = this.img_object.y() - dy;
      this.setCoords(new_x, new_y);
    },
    getContainerOffset() {
      return jQuery.extend({}, this.container.offset());
    },
    setCoords(x, y) {
      if (!this.img_object.loaded()) return;
      const coords = this._correctCoords(x, y);
      this.img_object.x(coords.x);
      this.img_object.y(coords.y);
    },
    _correctCoords(x, y) {
      x = parseInt(x, 10);
      y = parseInt(y, 10);
      if (y > 0) y = 0;
      if (x > 0) x = 0;
      if (y + this.img_object.display_height() < this.options.height) y = this.options.height - this.img_object.display_height();
      if (x + this.img_object.display_width() < this.options.width) x = this.options.width - this.img_object.display_width();
      if (this.img_object.display_width() <= this.options.width) x = -(this.img_object.display_width() - this.options.width) / 2;
      if (this.img_object.display_height() <= this.options.height) y = -(this.img_object.display_height() - this.options.height) / 2;
      return { x, y };
    },
    containerToImage(x, y) {
      let coords = { x: x - this.img_object.x(), y: y - this.img_object.y() };
      coords = this.img_object.toOriginalCoords(coords);
      return {
        x: util.descaleValue(coords.x, this.current_zoom),
        y: util.descaleValue(coords.y, this.current_zoom),
      };
    },
    imageToContainer(x, y) {
      const coords = {
        x: util.scaleValue(x, this.current_zoom),
        y: util.scaleValue(y, this.current_zoom),
      };
      return this.img_object.toRealCoords(coords);
    },
    _getMouseCoords(e) {
      const containerOffset = this.container.offset();
      coords = this.containerToImage(
        e.pageX - containerOffset.left,
        e.pageY - containerOffset.top,
      );
      return coords;
    },
    set_zoom(new_zoom, skip_animation, zoom_center) {
      if (this._trigger('onZoom', 0, new_zoom) == false) return;
      if (!this.img_object.loaded()) return;
      zoom_center = zoom_center || {
        x: Math.round(this.options.width / 2),
        y: Math.round(this.options.height / 2),
      };
      if (new_zoom < this.options.zoom_min) new_zoom = this.options.zoom_min;
      else if (new_zoom > this.options.zoom_max) new_zoom = this.options.zoom_max;
      if (this.current_zoom == 'fit') {
        var old_x = zoom_center.x + Math.round(this.img_object.orig_width() / 2);
        var old_y = zoom_center.y + Math.round(this.img_object.orig_height() / 2);
        this.current_zoom = 100;
      } else {
        var old_x = -this.img_object.x() + zoom_center.x;
        var old_y = -this.img_object.y() + zoom_center.y;
      }
      let new_width = util.scaleValue(this.img_object.orig_width(), new_zoom);
      let new_height = util.scaleValue(this.img_object.orig_height(), new_zoom);
      let new_x = util.scaleValue(
        util.descaleValue(old_x, this.current_zoom),
        new_zoom,
      );
      let new_y = util.scaleValue(
        util.descaleValue(old_y, this.current_zoom),
        new_zoom,
      );
      new_x = zoom_center.x - new_x;
      new_y = zoom_center.y - new_y;
      new_width = Math.floor(new_width);
      new_height = Math.floor(new_height);
      new_x = Math.floor(new_x);
      new_y = Math.floor(new_y);
      this.img_object.display_width(new_width);
      this.img_object.display_height(new_height);
      const coords = this._correctCoords(new_x, new_y);


      const self = this;
      this.img_object.setImageProps(
        new_width,
        new_height,
        coords.x,
        coords.y,
        skip_animation,
        () => {
          self._trigger('onAfterZoom', 0, new_zoom);
        },
      );
      this.current_zoom = new_zoom;
      this.update_status();
    },
    zoom_by(delta, zoom_center) {
      const closest_rate = this.find_closest_zoom_rate(this.current_zoom);
      const next_rate = closest_rate + delta;
      let next_zoom = this.options.zoom_base * Math.pow(this.options.zoom_delta, next_rate);
      if (delta > 0 && next_zoom < this.current_zoom) next_zoom *= this.options.zoom_delta;
      if (delta < 0 && next_zoom > this.current_zoom) next_zoom /= this.options.zoom_delta;
      this.set_zoom(next_zoom, undefined, zoom_center);
    },
    angle(deg, abs) {
      if (arguments.length === 0) return this.img_object.angle();
      if (deg < -270 || deg > 270 || deg % 90 !== 0) return;
      if (!abs) deg += this.img_object.angle();
      if (deg < 0) deg += 360;
      if (deg >= 360) deg -= 360;
      if (deg === this.img_object.angle()) return;
      this.img_object.angle(deg);
      this.center();
      this._trigger('angle', 0, { angle: this.img_object.angle() });
    },
    find_closest_zoom_rate(value) {
      if (value == this.options.zoom_base) return 0;
      function div(val1, val2) {
        return val1 / val2;
      }
      function mul(val1, val2) {
        return val1 * val2;
      }
      const func = value > this.options.zoom_base ? mul : div;
      const sgn = value > this.options.zoom_base ? 1 : -1;
      const mltplr = this.options.zoom_delta;
      let rate = 1;
      while (
        Math.abs(func(this.options.zoom_base, Math.pow(mltplr, rate)) - value)
        > Math.abs(
          func(this.options.zoom_base, Math.pow(mltplr, rate + 1)) - value,
        )
      ) rate++;
      return sgn * rate;
    },
    update_status() {
      if (!this.options.ui_disabled) {
        const percent = Math.round(
          (100 * this.img_object.display_height())
            / this.img_object.orig_height(),
        );
        if (percent) this.zoom_object.html(`${percent}%`);
      }
    },
    info(param, withoutRotation) {
      if (!param) return;
      switch (param) {
        case 'orig_width':
        case 'orig_height':
          if (withoutRotation) {
            return this.img_object.angle() % 180 === 0
              ? this.img_object[param]()
              : param === 'orig_width'
                ? this.img_object.orig_height()
                : this.img_object.orig_width();
          }
          return this.img_object[param]();
        case 'display_width':
        case 'display_height':
        case 'angle':
          return this.img_object[param]();
        case 'zoom':
          return this.current_zoom;
        case 'src':
          return this.img_object.object().attr('src');
        case 'coords':
          return { x: this.img_object.x(), y: this.img_object.y() };
      }
    },
    _mouseStart(e) {
      $.ui.mouse.prototype._mouseStart.call(this, e);
      if (this._trigger('onStartDrag', 0, this._getMouseCoords(e)) === false) return false;
      this.container.addClass('iviewer_drag_cursor');
      this._dragInitialized = !(
        e.originalEvent.changedTouches
        && e.originalEvent.changedTouches.length == 1
      );
      this.dx = e.pageX - this.img_object.x();
      this.dy = e.pageY - this.img_object.y();
      return true;
    },
    _mouseCapture(e) {
      return true;
    },
    _handleMouseMove(e) {
      this._trigger('onMouseMove', e, this._getMouseCoords(e));
    },
    _mouseDrag(e) {
      $.ui.mouse.prototype._mouseDrag.call(this, e);
      if (!this._dragInitialized) {
        this.dx = e.pageX - this.img_object.x();
        this.dy = e.pageY - this.img_object.y();
        this._dragInitialized = true;
      }
      const ltop = e.pageY - this.dy;
      const lleft = e.pageX - this.dx;
      this.setCoords(lleft, ltop);
      this._trigger('onDrag', e, this._getMouseCoords(e));
      return false;
    },
    _mouseStop(e) {
      $.ui.mouse.prototype._mouseStop.call(this, e);
      this.container.removeClass('iviewer_drag_cursor');
      this._trigger('onStopDrag', 0, this._getMouseCoords(e));
    },
    _click(e) {
      this._trigger('onClick', 0, this._getMouseCoords(e));
    },
    createui() {
      const me = this;
      $('<div>', { class: 'iviewer_zoom_in iviewer_common iviewer_button' })
        .bind('mousedown touchstart', () => {
          me.zoom_by(1);
          return false;
        })
        .appendTo(this.container);
      $('<div>', { class: 'iviewer_zoom_out iviewer_common iviewer_button' })
        .bind('mousedown touchstart', () => {
          me.zoom_by(-1);
          return false;
        })
        .appendTo(this.container);
      $('<div>', { class: 'iviewer_zoom_zero iviewer_common iviewer_button' })
        .bind('mousedown touchstart', () => {
          me.set_zoom(100);
          return false;
        })
        .appendTo(this.container);
      $('<div>', { class: 'iviewer_zoom_fit iviewer_common iviewer_button' })
        .bind('mousedown touchstart', function () {
          me.fit(this);
          return false;
        })
        .appendTo(this.container);
      this.zoom_object = $('<div>')
        .addClass('iviewer_zoom_status iviewer_common')
        .appendTo(this.container);
      $('<div>', { class: 'iviewer_rotate_left iviewer_common iviewer_button' })
        .bind('mousedown touchstart', () => {
          me.angle(-90);
          return false;
        })
        .appendTo(this.container);
      $('<div>', {
        class: 'iviewer_rotate_right iviewer_common iviewer_button',
      })
        .bind('mousedown touchstart', () => {
          me.angle(90);
          return false;
        })
        .appendTo(this.container);
      this.update_status();
    },
  });
  $.ui.iviewer.ImageObject = function (do_anim) {
    this._img = $('<img>').css({
      position: 'absolute',
      top: '0px',
      left: '0px',
    });
    this._loaded = false;
    this._swapDimensions = false;
    this._do_anim = do_anim || false;
    this.x(0, true);
    this.y(0, true);
    this.angle(0);
  };
  (function () {
    this._reset = function (w, h) {
      this._angle = 0;
      this._swapDimensions = false;
      this.x(0);
      this.y(0);
      this.orig_width(w);
      this.orig_height(h);
      this.display_width(w);
      this.display_height(h);
    };
    this.loaded = function () {
      return this._loaded;
    };
    this.load = function (src, loaded, error) {
      const self = this;
      loaded = loaded || jQuery.noop;
      this._loaded = false;
      const img = new Image();
      img.onload = function () {
        self._loaded = true;
        self._reset(this.width, this.height);
        self._img
          .removeAttr('width')
          .removeAttr('height')
          .removeAttr('style')
          .css({
            position: 'absolute',
            top: '0px',
            left: '0px',
            maxWidth: 'none',
          });
        self._img[0].src = src;
        loaded();
      };
      img.onerror = error;
      setTimeout(() => {
        img.src = src;
      }, 0);
      this.angle(0);
    };
    this._dimension = function (prefix, name) {
      const horiz = `_${prefix}_${name}`;


      const vert = `_${prefix}_${name === 'height' ? 'width' : 'height'}`;
      return setter(
        function (val) {
          this[this._swapDimensions ? horiz : vert] = val;
        },
        function () {
          return this[this._swapDimensions ? horiz : vert];
        },
      );
    };
    (this.display_width = this._dimension('display', 'width')),
    (this.display_height = this._dimension('display', 'height')),
    (this.display_diff = function () {
      return Math.floor(this.display_width() - this.display_height());
    });
    (this.orig_width = this._dimension('orig', 'width')),
    (this.orig_height = this._dimension('orig', 'height')),
    (this.x = setter(
      function (val, skipCss) {
        this._x = val;
        if (!skipCss) {
          this._finishAnimation();
          this._img.css(
            'left',
            `${this._x
                + (this._swapDimensions ? this.display_diff() / 2 : 0)
            }px`,
          );
        }
      },
      function () {
        return this._x;
      },
    ));
    this.y = setter(
      function (val, skipCss) {
        this._y = val;
        if (!skipCss) {
          this._finishAnimation();
          this._img.css(
            'top',
            `${this._y
              - (this._swapDimensions ? this.display_diff() / 2 : 0)
            }px`,
          );
        }
      },
      function () {
        return this._y;
      },
    );
    this.angle = setter(
      function (deg) {
        const prevSwap = this._swapDimensions;
        this._angle = deg;
        this._swapDimensions = deg % 180 !== 0;
        if (prevSwap !== this._swapDimensions) {
          const verticalMod = this._swapDimensions ? -1 : 1;
          this.x(this.x() - (verticalMod * this.display_diff()) / 2, true);
          this.y(this.y() + (verticalMod * this.display_diff()) / 2, true);
        }
        const cssVal = `rotate(${deg}deg)`;


        const img = this._img;
        jQuery.each(['', '-webkit-', '-moz-', '-o-', '-ms-'], (
          i,
          prefix,
        ) => {
          img.css(`${prefix}transform`, cssVal);
        });
        if (useIeTransforms) {
          jQuery.each(['-ms-', ''], (i, prefix) => {
            img.css(`${prefix}filter`, ieTransforms[deg].filter);
          });
          img.css({
            marginLeft:
              (ieTransforms[deg].marginLeft * this.display_diff()) / 2,
            marginTop: (ieTransforms[deg].marginTop * this.display_diff()) / 2,
          });
        }
      },
      function () {
        return this._angle;
      },
    );
    this.toOriginalCoords = function (point) {
      switch (this.angle()) {
        case 0:
          return { x: point.x, y: point.y };
        case 90:
          return { x: point.y, y: this.display_width() - point.x };
        case 180:
          return {
            x: this.display_width() - point.x,
            y: this.display_height() - point.y,
          };
        case 270:
          return { x: this.display_height() - point.y, y: point.x };
      }
    };
    this.toRealCoords = function (point) {
      switch (this.angle()) {
        case 0:
          return {
            x: this.x() + point.x,
            y: this.y() + point.y,
          };
        case 90:
          return {
            x: this.x() + this.display_width() - point.y,
            y: this.y() + point.x,
          };
        case 180:
          return {
            x: this.x() + this.display_width() - point.x,
            y: this.y() + this.display_height() - point.y,
          };
        case 270:
          return {
            x: this.x() + point.y,
            y: this.y() + this.display_height() - point.x,
          };
      }
    };
    this.object = setter(jQuery.noop, function () {
      return this._img;
    });
    this.setImageProps = function (
      disp_w,
      disp_h,
      x,
      y,
      skip_animation,
      complete,
    ) {
      complete = complete || jQuery.noop;
      this.display_width(disp_w);
      this.display_height(disp_h);
      this.x(x, true);
      this.y(y, true);
      const w = this._swapDimensions ? disp_h : disp_w;
      const h = this._swapDimensions ? disp_w : disp_h;
      const params = {
        width: w,
        height: h,
        top: `${y - (this._swapDimensions ? this.display_diff() / 2 : 0)}px`,
        left: `${x + (this._swapDimensions ? this.display_diff() / 2 : 0)}px`,
      };
      if (useIeTransforms) {
        jQuery.extend(params, {
          marginLeft:
            (ieTransforms[this.angle()].marginLeft * this.display_diff()) / 2,
          marginTop:
            (ieTransforms[this.angle()].marginTop * this.display_diff()) / 2,
        });
      }
      const swapDims = this._swapDimensions;


      const img = this._img;
      if (useIeTransforms && swapDims) {
        var ieh = this._img.width();


        var iew = this._img.height();


        var iedh = params.height - ieh;
        iedw = params.width - iew;
        delete params.width;
        delete params.height;
      }
      if (this._do_anim && !skip_animation) {
        this._img.stop(true).animate(params, {
          duration: 200,
          complete,
          step(now, fx) {
            if (useIeTransforms && swapDims && fx.prop === 'top') {
              const percent = (now - fx.start) / (fx.end - fx.start);
              img.height(ieh + iedh * percent);
              img.width(iew + iedw * percent);
              img.css('top', now);
            }
          },
        });
      } else {
        this._img.css(params);
        setTimeout(complete, 0);
      }
    };
    this._finishAnimation = function () {
      this._img.stop(true, true);
    };
  }.apply($.ui.iviewer.ImageObject.prototype));
  var util = {
    scaleValue(value, toZoom) {
      return (value * toZoom) / 100;
    },
    descaleValue(value, fromZoom) {
      return (value * 100) / fromZoom;
    },
  };
}(jQuery, undefined));
