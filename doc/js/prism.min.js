/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */ (function () {
  const e = /\blang(?:uage)?-(?!\*)(\w+)\b/i;


  var t = (self.Prism = {
    util: {
      type(e) {
        return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1];
      },
      clone(e) {
        const n = t.util.type(e);
        switch (n) {
          case 'Object':
            var r = {};
            for (const i in e) e.hasOwnProperty(i) && (r[i] = t.util.clone(e[i]));
            return r;
          case 'Array':
            return e.slice();
        }
        return e;
      },
    },
    languages: {
      extend(e, n) {
        const r = t.util.clone(t.languages[e]);
        for (const i in n) r[i] = n[i];
        return r;
      },
      insertBefore(e, n, r, i) {
        i = i || t.languages;
        const s = i[e];


        const o = {};
        for (const u in s) {
          if (s.hasOwnProperty(u)) {
            if (u == n) for (const a in r) r.hasOwnProperty(a) && (o[a] = r[a]);
            o[u] = s[u];
          }
        }
        return (i[e] = o);
      },
      DFS(e, n) {
        for (const r in e) {
          n.call(e, r, e[r]);
          t.util.type(e) === 'Object' && t.languages.DFS(e[r], n);
        }
      },
    },
    highlightAll(e, n) {
      const r = document.querySelectorAll(
        'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
      );
      for (var i = 0, s; (s = r[i++]);) t.highlightElement(s, e === !0, n);
    },
    highlightElement(r, i, s) {
      let o;


      let u;


      let a = r;
      while (a && !e.test(a.className)) a = a.parentNode;
      if (a) {
        o = (a.className.match(e) || [, ''])[1];
        u = t.languages[o];
      }
      if (!u) return;
      r.className = `${r.className.replace(e, '').replace(/\s+/g, ' ')} language-${o}`;
      a = r.parentNode;
      /pre/i.test(a.nodeName)
          && (a.className = `${a.className.replace(e, '').replace(/\s+/g, ' ')} language-${o}`);
      let f = r.textContent;
      if (!f) return;
      f = f
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/\u00a0/g, ' ');
      const l = {
        element: r, language: o, grammar: u, code: f,
      };
      t.hooks.run('before-highlight', l);
      if (i && self.Worker) {
        const c = new Worker(t.filename);
        c.onmessage = function (e) {
          l.highlightedCode = n.stringify(JSON.parse(e.data), o);
          t.hooks.run('before-insert', l);
          l.element.innerHTML = l.highlightedCode;
          s && s.call(l.element);
          t.hooks.run('after-highlight', l);
        };
        c.postMessage(JSON.stringify({ language: l.language, code: l.code }));
      } else {
        l.highlightedCode = t.highlight(l.code, l.grammar, l.language);
        t.hooks.run('before-insert', l);
        l.element.innerHTML = l.highlightedCode;
        s && s.call(r);
        t.hooks.run('after-highlight', l);
      }
    },
    highlight(e, r, i) {
      return n.stringify(t.tokenize(e, r), i);
    },
    tokenize(e, n, r) {
      const i = t.Token;


      const s = [e];


      const o = n.rest;
      if (o) {
        for (var u in o) n[u] = o[u];
        delete n.rest;
      }
      e: for (var u in n) {
        if (!n.hasOwnProperty(u) || !n[u]) continue;
        let a = n[u];


        const f = a.inside;


        const l = !!a.lookbehind;


        let c = 0;
        a = a.pattern || a;
        for (let h = 0; h < s.length; h++) {
          const p = s[h];
          if (s.length > e.length) break e;
          if (p instanceof i) continue;
          a.lastIndex = 0;
          var d = a.exec(p);
          if (d) {
            l && (c = d[1].length);
            const v = d.index - 1 + c;


            var d = d[0].slice(c);


            const m = d.length;


            const g = v + m;


            const y = p.slice(0, v + 1);


            const b = p.slice(g + 1);


            const w = [h, 1];
            y && w.push(y);
            const E = new i(u, f ? t.tokenize(d, f) : d);
            w.push(E);
            b && w.push(b);
            Array.prototype.splice.apply(s, w);
          }
        }
      }
      return s;
    },
    hooks: {
      all: {},
      add(e, n) {
        const r = t.hooks.all;
        r[e] = r[e] || [];
        r[e].push(n);
      },
      run(e, n) {
        const r = t.hooks.all[e];
        if (!r || !r.length) return;
        for (var i = 0, s; (s = r[i++]);) s(n);
      },
    },
  });


  var n = (t.Token = function (e, t) {
    this.type = e;
    this.content = t;
  });
  n.stringify = function (e, r, i) {
    if (typeof e === 'string') return e;
    if (Object.prototype.toString.call(e) == '[object Array]') {
      return e
        .map(t => n.stringify(t, r, e))
        .join('');
    }
    const s = {
      type: e.type,
      content: n.stringify(e.content, r, i),
      tag: 'span',
      classes: ['token', e.type],
      attributes: {},
      language: r,
      parent: i,
    };
    s.type == 'comment' && (s.attributes.spellcheck = 'true');
    t.hooks.run('wrap', s);
    let o = '';
    for (const u in s.attributes) o += `${u}="${s.attributes[u] || ''}"`;
    return (
      `<${
        s.tag
      } class="${
        s.classes.join(' ')
      }" ${
        o
      }>${
        s.content
      }</${
        s.tag
      }>`
    );
  };
  if (!self.document) {
    self.addEventListener(
      'message',
      (e) => {
        const n = JSON.parse(e.data);


        const r = n.language;


        const i = n.code;
        self.postMessage(JSON.stringify(t.tokenize(i, t.languages[r])));
        self.close();
      },
      !1,
    );
    return;
  }
  let r = document.getElementsByTagName('script');
  r = r[r.length - 1];
  if (r) {
    t.filename = r.src;
    document.addEventListener
      && !r.hasAttribute('data-manual')
      && document.addEventListener('DOMContentLoaded', t.highlightAll);
  }
}());
Prism.languages.markup = {
  comment: /&lt;!--[\w\W]*?-->/g,
  prolog: /&lt;\?.+?\?>/,
  doctype: /&lt;!DOCTYPE.+?>/,
  cdata: /&lt;!\[CDATA\[[\w\W]*?]]>/i,
  tag: {
    pattern: /&lt;\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|\w+))?\s*)*\/?>/gi,
    inside: {
      tag: {
        pattern: /^&lt;\/?[\w:-]+/i,
        inside: { punctuation: /^&lt;\/?/, namespace: /^[\w-]+?:/ },
      },
      'attr-value': {
        pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi,
        inside: { punctuation: /=|>|"/g },
      },
      punctuation: /\/?>/g,
      'attr-name': { pattern: /[\w:-]+/g, inside: { namespace: /^[\w-]+?:/ } },
    },
  },
  entity: /&amp;#?[\da-z]{1,8};/gi,
};
Prism.hooks.add('wrap', (e) => {
  e.type === 'entity' && (e.attributes.title = e.content.replace(/&amp;/, '&'));
});
Prism.languages.css = {
  comment: /\/\*[\w\W]*?\*\//g,
  atrule: {
    pattern: /@[\w-]+?.*?(;|(?=\s*{))/gi,
    inside: { punctuation: /[;:]/g },
  },
  url: /url\((["']?).*?\1\)/gi,
  selector: /[^\{\}\s][^\{\};]*(?=\s*\{)/g,
  property: /(\b|\B)[\w-]+(?=\s*:)/gi,
  string: /("|')(\\?.)*?\1/g,
  important: /\B!important\b/gi,
  ignore: /&(lt|gt|amp);/gi,
  punctuation: /[\{\};:]/g,
};
Prism.languages.markup
  && Prism.languages.insertBefore('markup', 'tag', {
    style: {
      pattern: /(&lt;|<)style[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/style(>|&gt;)/gi,
      inside: {
        tag: {
          pattern: /(&lt;|<)style[\w\W]*?(>|&gt;)|(&lt;|<)\/style(>|&gt;)/gi,
          inside: Prism.languages.markup.tag.inside,
        },
        rest: Prism.languages.css,
      },
    },
  });
Prism.languages.css.selector = {
  pattern: /[^\{\}\s][^\{\}]*(?=\s*\{)/g,
  inside: {
    'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/g,
    'pseudo-class': /:[-\w]+(?:\(.*\))?/g,
    class: /\.[-:\.\w]+/g,
    id: /#[-:\.\w]+/g,
  },
};
Prism.languages.insertBefore('css', 'ignore', {
  hexcode: /#[\da-f]{3,6}/gi,
  entity: /\\[\da-f]{1,8}/gi,
  number: /[\d%\.]+/g,
  function: /(attr|calc|cross-fade|cycle|element|hsla?|image|lang|linear-gradient|matrix3d|matrix|perspective|radial-gradient|repeating-linear-gradient|repeating-radial-gradient|rgba?|rotatex|rotatey|rotatez|rotate3d|rotate|scalex|scaley|scalez|scale3d|scale|skewx|skewy|skew|steps|translatex|translatey|translatez|translate3d|translate|url|var)/gi,
});
Prism.languages.clike = {
  comment: {
    pattern: /(^|[^\\])(\/\*[\w\W]*?\*\/|(^|[^:])\/\/.*?(\r?\n|$))/g,
    lookbehind: !0,
  },
  string: /("|')(\\?.)*?\1/g,
  'class-name': {
    pattern: /((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/gi,
    lookbehind: !0,
    inside: { punctuation: /(\.|\\)/ },
  },
  keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|catch|finally|null|break|continue)\b/g,
  boolean: /\b(true|false)\b/g,
  function: { pattern: /[a-z0-9_]+\(/gi, inside: { punctuation: /\(/ } },
  number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g,
  operator: /[-+]{1,2}|!|&lt;=?|>=?|={1,3}|(&amp;){1,2}|\|?\||\?|\*|\/|\~|\^|\%/g,
  ignore: /&(lt|gt|amp);/gi,
  punctuation: /[{}[\];(),.:]/g,
};
Prism.languages.javascript = Prism.languages.extend('clike', {
  keyword: /\b(var|let|if|else|while|do|for|return|in|instanceof|function|new|with|typeof|try|catch|finally|null|break|continue)\b/g,
  number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?|NaN|-?Infinity)\b/g,
});
Prism.languages.insertBefore('javascript', 'keyword', {
  regex: {
    pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,
    lookbehind: !0,
  },
});
Prism.languages.markup
  && Prism.languages.insertBefore('markup', 'tag', {
    script: {
      pattern: /(&lt;|<)script[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/script(>|&gt;)/gi,
      inside: {
        tag: {
          pattern: /(&lt;|<)script[\w\W]*?(>|&gt;)|(&lt;|<)\/script(>|&gt;)/gi,
          inside: Prism.languages.markup.tag.inside,
        },
        rest: Prism.languages.javascript,
      },
    },
  });
Prism.languages.php = Prism.languages.extend('clike', {
  keyword: /\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|extends|private|protected|parent|static|throw|null|echo|print|trait|namespace|use|final|yield|goto|instanceof|finally|try|catch)\b/gi,
  constant: /\b[A-Z0-9_]{2,}\b/g,
});
Prism.languages.insertBefore('php', 'keyword', {
  delimiter: /(\?>|&lt;\?php|&lt;\?)/gi,
  variable: /(\$\w+)\b/gi,
  package: {
    pattern: /(\\|namespace\s+|use\s+)[\w\\]+/g,
    lookbehind: !0,
    inside: { punctuation: /\\/ },
  },
});
Prism.languages.insertBefore('php', 'operator', {
  property: { pattern: /(->)[\w]+/g, lookbehind: !0 },
});
Prism.languages.markup
  && (Prism.hooks.add('before-highlight', (a) => {
    a.language === 'php'
      && ((a.tokenStack = []),
      (a.code = a.code.replace(
        /(?:&lt;\?php|&lt;\?|<\?php|<\?)[\w\W]*?(?:\?&gt;|\?>)/gi,
        (b) => {
          a.tokenStack.push(b);
          return `{{{PHP${a.tokenStack.length}}}}`;
        },
      )));
  }),
  Prism.hooks.add('after-highlight', (a) => {
    if (a.language === 'php') {
      for (var b = 0, c; (c = a.tokenStack[b]); b++) {
        a.highlightedCode = a.highlightedCode.replace(
          `{{{PHP${b + 1}}}}`,
          Prism.highlight(c, a.grammar, 'php'),
        );
      }
      a.element.innerHTML = a.highlightedCode;
    }
  }),
  Prism.hooks.add('wrap', (a) => {
    a.language === 'php'
      && a.type === 'markup'
      && (a.content = a.content.replace(
        /(\{\{\{PHP[0-9]+\}\}\})/g,
        '<span class="token php">$1</span>',
      ));
  }),
  Prism.languages.insertBefore('php', 'comment', {
    markup: {
      pattern: /(&lt;|<)[^?]\/?(.*?)(>|&gt;)/g,
      inside: Prism.languages.markup,
    },
    php: /\{\{\{PHP[0-9]+\}\}\}/g,
  }));
Prism.languages.insertBefore('php', 'variable', {
  this: /\$this/g,
  global: /\$_?(GLOBALS|SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/g,
  scope: {
    pattern: /\b[\w\\]+::/g,
    inside: { keyword: /(static|self|parent)/, punctuation: /(::|\\)/ },
  },
});
(function () {
  function e(e, t) {
    return Array.prototype.slice.call((t || document).querySelectorAll(e));
  }
  function n(e, t, n) {
    const r = t.replace(/\s+/g, '').split(',');


    const i = +e.getAttribute('data-line-offset') || 0;


    const s = parseFloat(getComputedStyle(e).lineHeight);
    for (var o = 0, u; (u = r[o++]);) {
      u = u.split('-');
      const a = +u[0];


      const f = +u[1] || a;


      const l = document.createElement('div');
      l.textContent = Array(f - a + 2).join(' \r\n');
      l.className = `${n || ''} line-highlight`;
      l.setAttribute('data-start', a);
      f > a && l.setAttribute('data-end', f);
      l.style.top = `${(a - i - 1) * s}px`;
      (e.querySelector('code') || e).appendChild(l);
    }
  }
  function r() {
    const t = location.hash.slice(1);
    e('.temporary.line-highlight').forEach((e) => {
      e.parentNode.removeChild(e);
    });
    const r = (t.match(/\.([\d,-]+)$/) || [, ''])[1];
    if (!r || document.getElementById(t)) return;
    const i = t.slice(0, t.lastIndexOf('.'));


    const s = document.getElementById(i);
    if (!s) return;
    s.hasAttribute('data-line') || s.setAttribute('data-line', '');
    n(s, r, 'temporary ');
    document.querySelector('.temporary.line-highlight').scrollIntoView();
  }
  if (!window.Prism) return;
  const t = (crlf = /\r?\n|\r/g);


  let i = 0;
  Prism.hooks.add('after-highlight', (t) => {
    const s = t.element.parentNode;


    const o = s && s.getAttribute('data-line');
    if (!s || !o || !/pre/i.test(s.nodeName)) return;
    clearTimeout(i);
    e('.line-highlight', s).forEach((e) => {
      e.parentNode.removeChild(e);
    });
    n(s, o);
    i = setTimeout(r, 1);
  });
  addEventListener('hashchange', r);
}());
Prism.hooks.add('after-highlight', (e) => {
  const t = e.element.parentNode;
  if (
    !t
    || !/pre/i.test(t.nodeName)
    || t.className.indexOf('line-numbers') === -1
  ) {
    return;
  }
  const n = 1 + e.code.split('\n').length;
  let r;
  lines = new Array(n);
  lines = lines.join('<span></span>');
  r = document.createElement('span');
  r.className = 'line-numbers-rows';
  r.innerHTML = lines;
  if (t.hasAttribute('data-start')) {
    t.style.counterReset = `linenumber ${parseInt(t.getAttribute('data-start'), 10) - 1}`;
  }
  e.element.appendChild(r);
});
(function () {
  if (!self.Prism || !self.document || !document.querySelector) return;
  const e = { js: 'javascript', html: 'markup', svg: 'markup' };
  Array.prototype.slice
    .call(document.querySelectorAll('pre[data-src]'))
    .forEach((t) => {
      const n = t.getAttribute('data-src');


      const r = (n.match(/\.(\w+)$/) || [, ''])[1];


      const i = e[r] || r;


      const s = document.createElement('code');
      s.className = `language-${i}`;
      t.textContent = '';
      s.textContent = 'Loading…';
      t.appendChild(s);
      const o = new XMLHttpRequest();
      o.open('GET', n, !0);
      o.onreadystatechange = function () {
        if (o.readyState == 4) {
          if (o.status < 400 && o.responseText) {
            s.textContent = o.responseText;
            Prism.highlightElement(s);
          } else {
            o.status >= 400
              ? (s.textContent = `✖ Error ${
                o.status
              } while fetching file: ${
                o.statusText}`)
              : (s.textContent = '✖ Error: File does not exist or is empty');
          }
        }
      };
      o.send(null);
    });
}());
